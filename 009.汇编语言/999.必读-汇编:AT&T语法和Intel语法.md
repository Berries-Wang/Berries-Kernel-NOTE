# 汇编语法: AT&T语法 和 Intel语法
> 结合[Brennan's Guide to Inline Assembly](./098.REF-DOCS/Inline%20Assembly%20with%20DJGPP.pdf) 学习

### **AT&T 汇编语法详解**
AT&T 语法是 **GNU 汇编器（GAS, GNU Assembler）** 使用的语法，主要用于 **Unix/Linux** 系统（如 GCC 内联汇编）。它与 **Intel 语法**（如 NASM、MASM）有较大区别。

---

## **1. 基本语法格式**
### **(1) 指令格式**
```asm
指令助记符 源操作数, 目标操作数
```
- **操作数顺序**：`源 -> 目标`（与 Intel 语法相反）。
- **寄存器**：前面加 `%`，如 `%eax`、`%ebx`。
- **立即数**：前面加 `$`，如 `$1`、`$0x80`。
- **内存引用**：用 `()` 表示，如 `(%eax)` 表示 `eax` 指向的内存。

### **示例对比（AT&T vs Intel）**
| 操作                | AT&T 语法               | Intel 语法           |
|---------------------|------------------------|----------------------|
| 移动立即数到寄存器   | `mov $1, %eax`         | `mov eax, 1`         |
| 移动寄存器到寄存器   | `mov %eax, %ebx`       | `mov ebx, eax`       |
| 移动内存到寄存器     | `mov (%eax), %ebx`     | `mov ebx, [eax]`     |
| 移动寄存器到内存     | `mov %ebx, (%eax)`     | `mov [eax], ebx`     |

---

## **2. 操作数大小**
在 AT&T 语法中，**指令后缀** 表示操作数大小：
| 后缀 | 操作数大小 | 示例               |
|------|------------|--------------------|
| `b`  | 1 字节（byte）  | `movb $1, %al`     |
| `w`  | 2 字节（word）  | `movw $1, %ax`     |
| `l`  | 4 字节（long）  | `movl $1, %eax`    |
| `q`  | 8 字节（quad）  | `movq $1, %rax`    |

**示例**：
```asm
movb $0x12, %al    ; 8位操作
movw $0x1234, %ax  ; 16位操作
movl $0x12345678, %eax ; 32位操作
movq $0x123456789ABCDEF, %rax ; 64位操作
```

---

## **3. 内存寻址方式**
### **(1) 直接寻址**
```asm
movl 0x12345678, %eax  ; 从内存地址 0x12345678 读取 4 字节到 eax
```
### **(2) 寄存器间接寻址**
```asm
movl (%ebx), %eax  ; 从 ebx 指向的内存读取 4 字节到 eax
```
### **(3) 带偏移的间接寻址**
```asm
movl 4(%ebx), %eax  ; 从 ebx + 4 指向的内存读取 4 字节到 eax
```
### **(4) 基址+变址寻址**
```asm
movl (%ebx,%ecx,4), %eax  ; 从 ebx + ecx*4 指向的内存读取 4 字节到 eax
```
### **(5) 绝对寻址（32/64位）**
```asm
movl 0x8048000, %eax  ; 从固定地址 0x8048000 读取数据
```

---

## **4. 常见指令示例**
### **(1) 数据移动**
```asm
movl $42, %eax       ; eax = 42 ; 操作立即数
movl %eax, %ebx      ; ebx = eax
movl (%esp), %eax    ; eax = [esp]
movl %eax, 4(%esp)   ; [esp+4] = eax
```

### **(2) 算术运算**
```asm
addl $10, %eax       ; eax += 10
subl %ebx, %eax      ; eax -= ebx
imull %ecx, %eax     ; eax *= ecx (有符号)
divl %ebx            ; eax = eax / ebx (无符号除法)
```

### **(3) 控制流**
```asm
jmp label            ; 无条件跳转
je label             ; 等于时跳转
jne label            ; 不等于时跳转
cmp %eax, %ebx       ; 比较 ebx 和 eax
test %eax, %eax      ; 测试 eax 是否为零
call func            ; 调用函数
ret                  ; 返回
```

### **(4) 栈操作**
```asm
pushl %eax           ; esp -= 4, [esp] = eax
popl %ebx            ; ebx = [esp], esp += 4
```

---

## **5. GCC 内联汇编示例**
```c
int a = 10, b;
asm("movl %1, %%eax; movl %%eax, %0;" 
    : "=r"(b)        // 输出操作数
    : "r"(a)         // 输入操作数
    : "%eax"         // 破坏的寄存器
);
```
- `%0`、`%1` 分别代表第 0 个和第 1 个操作数。
- `%%eax` 表示汇编代码中的寄存器（`%` 在 C 内联汇编中需要转义）。

---

## **6. AT&T vs Intel 语法对比**
| 特性         | AT&T 语法               | Intel 语法           |
|-------------|------------------------|----------------------|
| **操作数顺序** | `mov 源, 目标`         | `mov 目标, 源`       |
| **寄存器**    | `%eax`                 | `eax`(无符号（直接使用寄存器名）) |
| **立即数**    | `$1`                   | `1`(直接书写数值)      |
| **内存引用**  | `(%eax)`               | `[eax]`              |
| **指令后缀**  | `movb`, `movw`, `movl` | 无（由操作数决定）    |

---

## **总结**
- **AT&T 语法** 主要用于 **GNU 工具链**（如 GCC、GDB）。
- **操作数顺序** 是 `源, 目标`（与 Intel 相反）。
- **寄存器** 加 `%`，**立即数** 加 `$`，**内存引用** 用 `()`。
- **指令后缀**（`b`/`w`/`l`/`q`）决定操作数大小。

如果你熟悉 **Intel 语法**，转换到 **AT&T 语法** 主要注意：
1. **操作数顺序相反**。
2. **寄存器、立即数、内存引用的写法不同**。
3. **可能需要指令后缀**（如 `movl` 而不是 `mov`）。

希望这份指南能帮助你掌握 AT&T 汇编语法！🚀
