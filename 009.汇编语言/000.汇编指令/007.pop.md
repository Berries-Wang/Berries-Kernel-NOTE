# pop 指令
### **`popl` 汇编指令详解（AT&T 语法）**
`popl` 是 **AT&T 语法** 下的 **32 位出栈指令**，用于从栈顶弹出一个 32 位（4 字节）数据并存储到目标操作数，同时调整栈指针 `%esp`。  
- `pop` = 出栈操作  
- `l` = **long (32-bit)**（对应 `w`=word, `q`=quad）

---

## **1. 基本语法**
```asm
popl 目标操作数  # 目标操作数 = [esp], esp += 4
```
- **操作数**：可以是 **寄存器** 或 **内存地址**。
- **栈指针变化**：`%esp` **增加 4**（栈向低地址增长）。
- **等效操作**：
  ```asm
  movl (%esp), 目标操作数  # 读取栈顶数据
  addl $4, %esp          # 栈指针 +4
  ```

---

## **2. 常见用法**
### **(1) 弹出到寄存器**
```asm
popl %eax  # eax = [esp], esp += 4
```
### **(2) 弹出到内存**
```asm
popl var   # var = [esp], esp += 4
popl (%ebx)  # [ebx] = [esp], esp += 4
```
### **(3) 连续弹出多个值**
```asm
popl %eax  # 弹出第一个值到 eax
popl %ebx  # 弹出第二个值到 ebx
```

---

## **3. 与 `pushl` 配合使用**
`popl` 通常与 `pushl`（入栈）配对，用于 **保存和恢复寄存器** 或 **传递函数参数**。  
**示例**：
```asm
pushl %eax  # 将 eax 压栈（esp -= 4, [esp] = eax）
pushl %ebx  # 将 ebx 压栈
...         # 其他操作
popl %ebx   # 恢复 ebx（ebx = [esp], esp += 4）
popl %eax   # 恢复 eax
```

---

## **4. 对比不同位宽的 `pop`**
| 指令   | 操作数大小 | 栈指针变化 | 示例             |
|--------|------------|------------|------------------|
| `popw` | 16-bit     | `esp += 2` | `popw %ax`       |
| `popl` | 32-bit     | `esp += 4` | `popl %eax`      |
| `popq` | 64-bit     | `rsp += 8` | `popq %rax`      |

**注**：64 位模式下需使用 `popq` 和 `%rsp`。

---

## **5. 典型应用场景**
### **(1) 恢复寄存器状态**
```asm
pushl %eax      # 保存 eax
pushl %ebx      # 保存 ebx
...             # 其他操作可能修改 eax/ebx
popl %ebx       # 恢复 ebx
popl %eax       # 恢复 eax
```
### **(2) 函数返回后清理栈**
```asm
call func       # 调用函数（可能压入返回地址和参数）
addl $8, %esp   # 清理栈上的参数（或直接用 popl 弹出）
```
### **(3) 快速赋值**
```asm
pushl $42       # 压入立即数 42
popl %eax       # eax = 42
```

---

## **6. 注意事项**
1. **栈平衡**：  
   - `pushl` 和 `popl` 必须成对使用，否则会导致栈指针错误。
   - 函数调用后需确保栈恢复到调用前的状态（如通过 `addl $N, %esp` 或 `popl`）。

2. **操作数限制**：  
   - 不能直接 `pop` 到立即数（如 `popl $1` ❌）。
   - 内存操作数需明确大小（如 `popl var` 或 `popl (%edi)`）。

3. **64 位模式**：  
   - 使用 `popq` 和 64 位寄存器（如 `%rax`）。

---

## **7. 与 Intel 语法对比**
| 操作              | AT&T 语法        | Intel 语法       |
|-------------------|-----------------|------------------|
| 弹出到寄存器       | `popl %eax`     | `pop eax`        |
| 弹出到内存         | `popl var`      | `pop [var]`      |

**关键区别**：
- AT&T 语法：操作数不加 `[]`，寄存器前加 `%`。
- Intel 语法：内存操作数用 `[]`，寄存器无前缀。

---

## **8. 总结**
| 要点               | 说明                                      |
|--------------------|------------------------------------------|
| **指令作用**       | 从栈顶弹出 32 位数据到目标操作数          |
| **栈指针变化**     | `%esp += 4`（栈向低地址增长）            |
| **操作数类型**     | 寄存器或内存地址                          |
| **与 `pushl` 关系**| 逆向操作（`pushl` 压栈，`popl` 弹栈）    |
| **常见用途**       | 恢复寄存器、清理栈、快速赋值              |

**示例速查**：
```asm
pushl %eax      # 压栈 eax
popl %ebx       # 弹栈到 ebx
popl (%esp)     # 弹栈到栈顶（通常无意义）
```

掌握 `popl` 后，可以轻松理解栈操作（如函数调用、参数传递）的核心机制！ 🚀