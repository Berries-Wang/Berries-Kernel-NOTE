# CALL指令
### **`call` 汇编指令详解**
`call` 是 x86 汇编语言中的 **函数调用指令**，用于跳转到子程序（函数）并保存返回地址。它的核心操作是 **将下一条指令的地址压栈**，然后修改 `EIP/RIP` 跳转到目标地址。

---

## **1. 基本功能**
```asm
call 目标地址
```
#### **等效操作**（32位模式）：
```asm
pushl %eip  ; 将 call 下一条指令的地址压栈（实际不可直接操作 EIP）
jmp 目标地址 ; 跳转到函数
```
- **栈指针变化**：`%esp -= 4`（32位）或 `%rsp -= 8`（64位）。
- **实际行为**：
  1. 将 `call` 指令的**下一条指令地址**（返回地址）压入栈。
  2. 跳转到 `目标地址` 执行函数代码。
  3. 函数结束时通过 `ret` 指令从栈弹出返回地址，继续执行。

---

## **2. 常见用法**
### **(1) 直接调用（静态地址）**
```asm
call my_func  ; 跳转到 my_func，压入返回地址
```
### **(2) 间接调用（寄存器/内存中的地址）**
```asm
call *%eax    ; 跳转到 eax 中的地址
call *(%ebx)  ; 跳转到 [ebx] 指向的地址
```
### **(3) 配合 `ret` 实现函数调用**
```asm
section .text
global _start
_start:
    call func      ; 调用函数
    movl $1, %eax  ; 退出系统调用（返回后执行）
    int $0x80

func:
    movl $42, %eax ; 设置返回值
    ret            ; 返回到 call 的下一条指令
```

---

## **3. 不同位宽模式下的行为**
| 模式       | 指令    | 返回地址大小 | 栈指针变化       |
|------------|---------|--------------|------------------|
| **32位**   | `call`  | 4 字节       | `%esp -= 4`      |
| **64位**   | `callq` | 8 字节       | `%rsp -= 8`      |
| **16位**   | `callw` | 2 字节       | `%sp -= 2`       |

**注**：64位模式下通常写作 `callq`（GAS 语法），但 `call` 也可用。

---

## **4. 关键注意事项**
1. **栈平衡**：
   - `call` 和 `ret` 必须配对使用，否则会导致栈指针错误。
   - 若函数有参数，需按调用约定压栈（如 `push arg1` 在 `call` 前）。

2. **调用约定**：
   - **cdecl**：调用者清理栈（`addl $N, %esp` 在 `call` 后）。
   - **stdcall**：被调用者清理栈（`ret N` 在函数内）。
   - **fastcall**：参数通过寄存器传递（如 `%ecx`, `%edx`）。

3. **保护寄存器**：
   - 根据约定，某些寄存器（如 `%ebx`, `%esi`, `%edi`）需由被调用者保存。

---

## **5. 典型场景示例**
### **(1) 普通函数调用**
```asm
section .text
global _start
_start:
    pushl $2       ; 压入第二个参数
    pushl $1       ; 压入第一个参数
    call add       ; 调用函数
    addl $8, %esp  ; 调用者清理栈（cdecl）
    movl $1, %eax  ; 退出系统调用
    int $0x80

add:
    movl 4(%esp), %eax  ; 取第一个参数
    addl 8(%esp), %eax  ; 加第二个参数
    ret                 ; 返回
```

### **(2) 通过寄存器间接调用**
```asm
movl $my_func, %eax
call *%eax  ; 跳转到 eax 中的地址
```

---

## **6. 与 Intel 语法对比**
| 操作              | AT&T 语法          | Intel 语法         |
|-------------------|--------------------|--------------------|
| 直接调用          | `call my_func`     | `call my_func`     |
| 间接调用          | `call *%eax`       | `call eax`         |
| 内存间接调用      | `call *(%ebx)`     | `call [ebx]`       |

**关键区别**：
- AT&T 语法：间接调用需加 `*`（如 `call *%eax`）。
- Intel 语法：直接写寄存器或内存（如 `call eax`）。

---

## **7. 总结**
| 要点               | 说明                                      |
|--------------------|------------------------------------------|
| **核心作用**       | 跳转到函数并保存返回地址                 |
| **底层操作**       | 压入 `EIP/RIP`，跳转到目标地址           |
| **栈指针变化**     | `%esp -= 4`（32位）或 `%rsp -= 8`（64位）|
| **与 `ret` 关系**  | `call` 压入地址，`ret` 弹出并返回        |
| **间接调用**       | 通过寄存器或内存中的地址跳转             |

**示例速查**：
```asm
call func       ; 直接调用
call *%eax      ; 跳转到 eax 中的地址
call *0x8048000 ; 跳转到内存地址 0x8048000
```

掌握 `call` 是理解函数调用、栈帧和程序控制流的基础！ 🚀