# sub
> subq 与 sub 一致，只是应用的CPU架构不同。类似:[mov、movq](./002.mov.md)
在 x86/x86-64 汇编语言中，`sub`（**subtract**）指令用于 **减法运算**，从目标操作数（destination operand）中减去源操作数（source operand），并将结果存储回目标操作数。以下是 `sub` 指令的详细解析：

---

### **1. 基本语法**
```asm
sub <目标操作数>, <源操作数>
```
- **目标操作数**：可以是寄存器或内存地址。
- **源操作数**：可以是寄存器、内存地址或立即数（常数）。

---

### **2. 操作规则**
- **结果**：`目标操作数 = 目标操作数 - 源操作数`。
- **标志位影响**：根据结果更新以下标志位：
  - `ZF`（零标志）：结果为 0 时置 1。
  - `SF`（符号标志）：结果为负数时置 1。
  - `CF`（进位标志）：无符号减法产生借位时置 1。
  - `OF`（溢出标志）：有符号减法溢出时置 1。

---

### **3. 常见用法示例**
#### **(1) 寄存器减立即数**
```asm
sub eax, 10     ; eax = eax - 10（32位）
sub rax, 0x20   ; rax = rax - 32（64位）
```

#### **(2) 寄存器减寄存器**
```asm
sub ebx, ecx    ; ebx = ebx - ecx
sub rsp, rbp    ; rsp = rsp - rbp
```

#### **(3) 内存地址减立即数**
```asm
sub dword [mem], 5   ; 内存中的32位值减5
sub qword [rsi], 8   ; rsi指向的64位值减8
```

#### **(4) 调整栈指针（经典用途）**
```asm
sub rsp, 16     ; 分配16字节栈空间（x86-64）
sub esp, 32     ; 分配32字节栈空间（x86）
```

---

### **4. 操作数大小**
- 根据操作数前缀或寄存器隐式确定操作数大小：
  - **32位**：`sub eax, ebx`  
  - **64位**：`sub rax, rbx`  
  - **16位**：`sub ax, bx`  
  - **8位**：`sub al, bl`  

若操作数大小不匹配，汇编器会报错。

---

### **5. 与 `add` 指令的对比**
| 指令 | 操作                | 典型用途                     |
|------|---------------------|------------------------------|
| `sub`| 目标 = 目标 - 源     | 减法运算、栈空间分配         |
| `add`| 目标 = 目标 + 源     | 加法运算、栈空间释放         |

---

### **6. 实际应用场景**
#### **(1) 函数开头的栈空间分配**
```asm
my_func:
    push rbp
    mov  rbp, rsp
    sub  rsp, 32      ; 分配32字节局部变量空间
    ...
```

#### **(2) 算术运算**
```asm
mov  eax, 100
sub  eax, 50         ; eax = 50
```

#### **(3) 循环计数器递减**
```asm
mov  ecx, 10
loop_start:
    ; 循环体...
    sub  ecx, 1      ; ecx--
    jnz  loop_start  ; 若 ecx ≠ 0 则跳转
```

---

### **7. 注意事项**
1. **立即数符号扩展**：  
   - 若源操作数是立即数且小于目标操作数大小，会被符号扩展。  
   - 例如：`sub rax, 0xFFFFFFFF`（32位立即数被符号扩展为64位）。

2. **内存操作数限制**：  
   - 两个操作数不能同时为内存地址，如 `sub [mem1], [mem2]` 是非法的。

3. **标志位敏感操作**：  
   - 若后续指令依赖标志位（如 `jz`, `jc`），需注意 `sub` 对标志位的修改。

---

### **8. 扩展指令**
- **`sbb`**：带借位减法（`dest = dest - src - CF`），用于大数运算。
- **`dec`**：单操作数减1（不影响 `CF` 标志）。

---

### **总结**
- `sub` 是基础的减法指令，用于算术运算、栈调整和计数器操作。
- 操作数大小需一致，结果会影响关键标志位（ZF/SF/CF/OF）。
- 在函数栈帧分配和循环控制中极为常见。

若需进一步分析具体代码中的 `sub` 指令，可提供上下文深入探讨！

---

## sub 、subq
在 x86 和 x86-64 汇编中，`sub` 和 `subq` 都是用于 **减法运算** 的指令，但它们的操作数大小和适用架构有所不同。以下是详细对比和解析：

---

### **1. `sub` 指令**
#### **基本语法**
```asm
sub <目标操作数>, <源操作数>
```
#### **特点**
- **操作数大小**：  
  - 在 **32 位模式** 下默认操作 **32 位数据**（如 `sub %eax, %ebx`）。  
  - 在 **16 位模式** 下默认操作 **16 位数据**（如 `sub %ax, %bx`）。  
  - 在 **64 位模式** 下，若目标操作数是 **64 位寄存器**（如 `%rax`），则隐式执行 64 位减法。

#### **示例**
```asm
sub %eax, %ebx    ; 32位：ebx = ebx - eax
sub $10, %ax      ; 16位：ax = ax - 10
sub $1, (%rsp)    ; 64位：将 rsp 指向的内存值减1（操作数大小由内存类型决定）
```

---

### **2. `subq` 指令**
#### **基本语法**
```asm
subq <目标操作数>, <源操作数>
```
#### **特点**
- **`q` 表示 quad-word（64 位）**，明确指定操作数为 **64 位**。  
- **仅用于 x86-64 架构**（64 位模式）。  
- 目标操作数必须是 **64 位寄存器或内存地址**，源操作数可以是立即数、寄存器或内存地址。

#### **示例**
```asm
subq $8, %rsp     ; rsp = rsp - 8（经典栈空间分配）
subq %rax, %rbx   ; rbx = rbx - rax
subq $0x10, (%rdi); 将 rdi 指向的64位内存值减16
```

---

### **3. 关键区别**
| 指令   | 操作数大小       | 适用模式       | 典型用途                     |
|--------|------------------|----------------|------------------------------|
| `sub`  | 隐式（16/32/64） | 16/32/64 位    | 通用减法，兼容不同模式        |
| `subq` | 显式 64 位       | 仅 x86-64      | 明确要求64位操作（代码更清晰）|

---

### **4. 常见用途**
#### **(1) 栈空间分配（x86-64）**
```asm
subq $16, %rsp   ; 分配16字节栈空间（64位模式）
```
- **等价于** `sub $16, %rsp`（在64位模式下，GAS汇编器会自动推断为 `subq`）。

#### **(2) 算术运算**
```asm
subq %rax, %rbx  ; rbx -= rax（64位）
sub $1, %ecx     ; ecx -= 1（32位）
```

#### **(3) 内存操作**
```asm
subq $8, (%rsi)  ; 将 rsi 指向的64位值减8
subw $2, (%rdi)  ; 将 rdi 指向的16位值减2（注意使用 `subw`）
```

---

### **5. 注意事项**
1. **操作数大小匹配**：  
   - `subq` 的目标操作数必须是64位（如 `%rax`、`(%rsp)`），否则汇编器会报错。  
   - 例如：`subq $1, %eax` 是无效的（`%eax` 是32位）。

2. **立即数符号扩展**：  
   - 若立即数小于64位，会被符号扩展。例如：  
     ```asm
     subq $0xFFFFFFFF, %rax  ; 实际减去 0xFFFFFFFFFFFFFFFF（符号扩展后）
     ```

3. **隐式优化**：  
   - 在 x86-64 模式下，`sub` 和 `subq` 通常生成相同的机器码，但 `subq` 更明确。

---

### **6. 扩展指令**
- **`subb`**：8 位减法（如 `subb $1, %al`）。  
- **`subw`**：16 位减法（如 `subw $2, %bx`）。  
- **`subl`**：32 位减法（如 `subl %ecx, %edx`）。  

---

### **总结**
- **`sub`**：通用减法指令，操作数大小由上下文决定（兼容16/32/64位）。  
- **`subq`**：明确指定64位减法，仅用于 x86-64，代码可读性更高。  
- **关键场景**：栈空间分配、计数器递减、算术运算。  

若需分析具体代码中的减法指令，可结合上下文进一步探讨！