# 一条存储读写指令的执行全过程
## 经典处理器架构的流水线是5级流水线，分别是取指、译码、执行、数据内存访问和写回。
1. 取指（IF: Instruction Fetch）
   - 功能：从内存中获取指令。这个阶段的主要任务是从程序计数器（PC）指向的地址加载指令，并将程序计数器更新为下一个指令地址。
   - 详细说明：在这个阶段，指令通过数据总线从内存中读取，送到指令寄存器中。

2. 指令译码（ID: Instruction Decode）
   - 功能：将指令**分解**为**操作码**（opcode）和**操作数**，识别需要的寄存器、常量等，并准备好后续的执行操作。
   - 详细说明：控制单元从指令中提取出操作码，然后根据操作码生成控制信号。此阶段还会读取寄存器中的值（如果指令需要寄存器操作），并且如果指令有立即数（如加法指令中的常数），也会解析出来。

3. 执行（EX: Execute）
   - 功能：执行算术逻辑运算（ALU）或者计算地址（如加法、减法、比较等）。
   - 详细说明：在这个阶段，算术逻辑单元（ALU）会根据操作码对数据执行相应的操作（如加法、减法、与运算等）。如果指令涉及到跳转或条件判断，执行阶段也会计算跳转地址或进行条件判断。

4. 内存访问（MEM: Memory Access）
   - 功能：访问数据内存进行读写操作。
   - 详细说明：如果指令需要从内存中加载数据（如 LW 指令）或将数据写入内存（如 SW 指令），则在这个阶段完成内存操作。此阶段不会发生任何计算，只是内存的数据传输。

5. 写回（WB: Write Back）
   - 功能：将运算结果写回寄存器或内存。
   - 详细说明：在这个阶段，执行完毕后的结果（如ALU运算结果）会被写回到目标寄存器，或者将从内存中读取的数据写入寄存器。

### 总结
经典的五段流水线由以下五个阶段组成：
- 取指（IF）
- 指令译码（ID）
- 执行（EX）
- 内存访问（MEM）
- 写回（WB）

每个阶段的任务是高度分工的，可以实现指令的并行处理，提高指令的执行效率。每个时钟周期，处理器可以处理不同阶段的多条指令，从而加快指令的执行速度。这种流水线架构是许多现代处理器的基础。


## 乱序执行
> 请阅读:  [奔跑吧Linux内核（第2版）卷1：基础架构#1.1.3一条存储读写指令的执行全过程](../006.BOOKs/Run%20Linux%20Kernel%20(2nd%20Edition)%20Volume%201:%20Infrastructure.epub)#1.1.3一条存储读写指令的执行全过程

乱序执行是在支持超标量架构和乱序执行技术的处理器当中，把一条存储-读-写指令的执行过程分解为若干步骤。
1. 指令首先进入流水线的前端，包括预取和译码
2. 经过分发和调度后进行执行单元
3. 最后提交执行结果。

所有的指令采用顺序方式经过前端，并采用乱序的方式进行发射，然后乱序执行，最后用顺序方式提交执行结果，并将最终的结果更新到加载-存储队列
> 指令发射是指在超标量处理器中，将已经解码的指令发送到适当的执行单元进行执行的过程。它通常发生在指令流水线的“执行”阶段之前，具体来说，是指令从指令调度阶段进入到实际的执行单元的过程。指令发射的目的是提高处理器的并行性和执行效率，使多个指令能够在同一时钟周期内并行执行。

乱序执行： 对于一串给定的指令序列，为了提高效率，处理器会找出非真正数据依赖和地址依赖的指令，让他们并行执行。但是在提交执行结果时，是按照指令次序提交的——即：顺序提交指令，乱序执行，最后顺序提交执行结果。（如果有两条没有数据依赖的数据指令，那么后面那条指令读的数据先返回，它的结果也不能先写回最终寄存器，而必须等到前一条指令完成之后才可以。）<sup>乱序执行： 对于一串给定的指令序列，为了提高效率，处理器会找出非真正数据依赖和地址依赖的指令，让他们并行执行。但是在提交执行结果时，是按照指令次序提交的——即：顺序提交指令，乱序执行，最后顺序提交执行结果。</sup>






---
## 参考
1.请阅读:  [奔跑吧Linux内核（第2版）卷1：基础架构#1.1.3一条存储读写指令的执行全过程](../006.BOOKs/Run%20Linux%20Kernel%20(2nd%20Edition)%20Volume%201:%20Infrastructure.epub)#1.1.3一条存储读写指令的执行全过程