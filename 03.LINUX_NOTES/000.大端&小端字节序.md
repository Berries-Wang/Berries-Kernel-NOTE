# 大端&小端字节序
计算机操作系统是以字节为单位存储信息的,每个地址单元对应1字节，1字节为8位<sup>重要!!!</sup> 。 但是在32位处理器中,C语言除了8位的char类型之外，还有16位的short类型、32位的int类型。另外，16位、32位等位数更高的处理器，由于寄存器宽度大于1字节，必然存在如何安排多字节的问题，因此导致了大端存储模式（big-endian）和小端存储模式(little-endian)的产生——<font color='red'>**大端&小端存储的由来**</font>

如一个16位的short类型变量X在内存中的地址为0x0010，X的值为0x1122，其中，0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，将0x22放在高地址中。小端模式则刚好相反

## 大端模式
大端模式指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。
```txt
    #在大端模式下，应该这样读取 0x1234 5678 
    0000430: 1234 5678 0000 0000 0000 0000 0000 0000
    0000440: 0000 0000 0000 0000 0000 0000 0100 0000
```
因此,大端模式下地址的增长顺序与值的增长顺序相同

## 小端模式
小端模式指数据的高字节保存在内存的保存在内存的高地址中,而数据的低字节保存在内存的低地址中.
```txt
   # 在小端模式下，应该这样读取 0x1234 5678
   0000430: 7856 3412 0000 0000 0000 0000 0000 0000
   0000440: 0000 0000 0000 0000 0000 0000 0000 0000
```
因此，小端模式下地址的增长顺序与值的增长顺序相反

### 疑问: 为什么是两两数字是一组
即，当读取 0x1234 5678的时候，为什么内存布局不是如下情况:
```txt
   # 注意，这 是错误的
   0000430: 8765 4321 0000 0000 0000 0000 0000 0000
   0000440: 0000 0000 0000 0000 0000 0000 0000 0000
```
#### 因为
1. 0x 是16进制,一个数字对应4个字节
2. 结合如上所述：'计算机操作系统是以字节为单位存储信息的,每个地址单元对应1字节，1字节为8位' ， 计算机操作系统存储是按照字节来存储的，一个字节是8位，所以，在OS中，0x1234 5678 存储单元就是： 0x12、0x34、0x56、0x78  (因为OS是按字节存储的，所以不能再细分了)

---

从上面大/小端模式的内存视图可知，同样是读取0x1234 5678 ,但是该值在内存中的布局是不一样的。
