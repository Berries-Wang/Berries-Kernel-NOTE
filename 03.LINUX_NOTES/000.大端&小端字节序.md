# 大端&小端字节序
计算机操作系统是以字节为单位存储信息的,每个地址单元对应1字节，1字节为8位<sup>重要!!!</sup> 。 但是在32位处理器中,C语言除了8位的char类型之外，还有16位的short类型、32位的int类型。另外，16位、32位等位数更高的处理器，由于寄存器宽度大于1字节，必然存在如何安排多字节的问题，因此导致了大端存储模式（big-endian）和小端存储模式(little-endian)的产生——<font color='red'>**大端&小端存储的由来**</font>

如一个16位的short类型变量X在内存中的地址为0x0010，X的值为0x1122，其中，0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，将0x22放在高地址中。小端模式则刚好相反

## 大端模式
大端模式指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。
```txt
    #在大端模式下，应该这样读取 0x1234 5678  (顺序: 低地址  -> 高地址)
    0000430: 1234 5678 0000 0000 0000 0000 0000 0000
    0000440: 0000 0000 0000 0000 0000 0000 0100 0000
```
因此,大端模式下地址的增长顺序与值的增长顺序相同

## 小端模式
小端模式指数据的高字节保存在内存的保存在内存的高地址中,而数据的低字节保存在内存的低地址中.
```txt
   # 在小端模式下，应该这样读取 0x1234 5678 (顺序: 低地址  -> 高地址)
   0000430: 7856 3412 0000 0000 0000 0000 0000 0000
   0000440: 0000 0000 0000 0000 0000 0000 0000 0000
```
因此，小端模式下地址的增长顺序与值的增长顺序相反

### 疑问: 为什么是两两数字是一组
即，当读取 0x1234 5678的时候，为什么内存布局不是如下情况:
```txt
   # 注意，这 是错误的  (顺序: 低地址  -> 高地址)
   0000430: 8765 4321 0000 0000 0000 0000 0000 0000
   0000440: 0000 0000 0000 0000 0000 0000 0000 0000
```
#### 因为
1. 0x 是16进制,一个数字对应4个字节
2. 结合如上所述：'计算机操作系统是以字节为单位存储信息的,每个地址单元对应1字节，1字节为8位' ， 计算机操作系统存储是按照字节来存储的，一个字节是8位，所以，在OS中，0x1234 5678 存储单元就是： 0x12、0x34、0x56、0x78  (因为OS是按字节存储的，所以不能再细分了)

---

## 如何判断处理器是大端模式还是小端模式
从上面大/小端模式的内存视图可知，同样是读取0x1234 5678 ,但是该值在内存中的布局是不一样的。

联合体(union)的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松判断CPU对内存采用大端模式还是小端模式读写。[代码示例 #001.OS-Endian.c](../004.TEST_CODE_SPACE/001.OS-Endian.c)
```c
   #include <stdio.h>
   #include <stdlib.h>
   
   /**
    * 校验处理器是大端模式还是小端模式:
    * 联合体（union）的存放顺序是所有成员都从低地址开始存放
    */
   void checkCPU(void) {
     union w {
       u_int64_t a;
       char b;
     } c;
     c.a = 1;
     if (c.b == 1) {
       printf("小端存储\n");
     } else {
       printf("小端存储\n");
     }
   }
   
   void checkCPU_V2(void) {
     union w {
       u_int64_t a;
       char b;
     } c;
     c.a = 0x12345678;
     if (c.b == 0x78) {
       printf("小端存储\n");
     } else {
       printf("小端存储\n");
     }
   }
   
   void checkCPU_V3(void) {
     u_int64_t *a = (u_int64_t *)malloc(sizeof(u_int64_t));
     *a = 0x12345678;
     char little_endian = ((char *)a)[3];
     if (little_endian == 0x12) {
       printf("小端存储\n");
     } else {
       printf("小端存储\n");
     }
   }
   
   int main(int argc, char **argv) {
     checkCPU();
     checkCPU_V2();
     checkCPU_V3();
     return 0;
   }
```

## 为什么没有统一?
1. 检查奇偶性(小端占优)
   ```txt
      通过查看个位数，确定某个数字是奇数还是偶数.
      # (顺序: 低地址  -> 高地址)
      小端: 0000430: 7856 3412 0000 0000 0000 0000 0000 0000
      大端: 0000430: 1234 5678 0000 0000 0000 0000 0000 0000

      小端只需要判断第一位是奇数还是偶数即可,即判断:0x78是奇数还是偶数
   ```
2. 检查正负号(大端占优)
   ```txt
     数字在操作系统中是以补码的形式存在的，最高一位表示正数还是负数，详见 操作系统 
     所以，判断数字是正数还是负数，只需要判断最高位是0(正数)还是1(负数)即可
   ```
3. 比较大小(小端占优)
   ```txt
     比较大小:
     1. 判断正负
     2. 判断位数
     3. 逐位比较大小
     
     大端模式: 需要读取所有位，再进行比较.

     小端模式: 通过第一位就可以判断是正数还是负数，若读取不到下一位，则读取不到下一位的那个数就比能读到下一位的数小。
   ```
4. 乘法(小端占优)
   ```txt
     大端序:
       大端序的乘法是向左进位，也就是向左拓展，必须等到每一轮的结果都出来，再相加统一写入内存.
       
       -> 改为小端序的乘法，则不需要等待下一轮的结果出来，每一轮都可以直接写入内存——因为最高位是不变的

     小端序：
       小端乘法是向右进位，也就是向右边拓展，左边的边界不变，每一轮结果写入内存后，就不需要移动，后面有变化只需要改动对应的位就行。
   ```
5. 任意精度整数(小端占优)
   ```txt
      任意精度整数 又称大整数，可以存放任意大小的整数
      它的内部实现是把整数分为一个个较小的单位，通常是uint32 或 uint64,按顺序组合在一起
      |u64|u64|u64|
      
      如果是大端序，第一个u64必须是这个整数最大部分，运算时，一旦这个数发生变化，需要进位，后面的所有位都必须移动和改写。小端序发生进位时，往往不需要所有位移动。
      
      小端序的另一个好处是 如果逐字节的运算从个位开始，可以从左网友一次运算一个个u64，算完上一个再读取下一个，大端就不行，必须读取整个数以后再进行.
   ```
6. 更改类型(小端占优)
   ```txt
      强制类型转换，即强制改变变量的数据类型，例如把32位整数强行变为16位整数，如下
      数字1
      ## 大端序
      32bits: 0x 00 00 00 00 00 00 00 01
      16bits: 0x 00 00 00 00 [00 00 00 01] # []框起来的就是16bits

      ## 小端序
      32bits: 0x 01 00 00 00 00 00 00 00
      16bits: 0x [01 00 00 00] 00 00 00 00 # []框起来的就是16bits

      32位整数 0x00000001 更改为16位整数0x0001 , 大端序需要截去前两个字节，这时候需要将指针往后移动两个字节.
      则小端序没有这个问题，截去的是后两个字节，第一位的地址是不变的，所以指针不需要移动.
   ```
7. 网络字节序和主机字节序
   ```txt
      网络字节序：TCP/IP各层协议将字节序定义为Big Endian，即大端模式，TCP/IP协议中使用的字节序是大端序，方便不同主机字节序的设备进行网络传输数据。
          --> 选择大端模式（Big Endian）作为网络传输的字节序，主要是为了统一性和跨平台兼容性。不同的计算机架构可能使用不同的字节序（大端或小端），而网络协议需要确保数据在不同系统之间传输时不会出现字节顺序错误
      主机字节序：整数在内存中存储的顺序，目前以Little Endian，即小端模式，比较普遍（不同的CPU有不同的字节序）。iOS、macOS都是小端序。
   ```

总结: 如果需要逐位运算，或者需要到从个位数开始运算，都是小端序占优势。反之，如果运算只涉及到高位，或者数据的可读性比较重要，则是大端序占优势。

## 参考
1. [奔跑吧Linux内核#1.1处理器架构介绍](../006.BOOKs/Run%20Linux%20Kernel%20(2nd%20Edition)%20Volume%201:%20Infrastructure.epub)#1.1处理器架构介绍