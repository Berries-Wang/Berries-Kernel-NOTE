# 内存屏障产生原因
若程序在执行时的内存访问顺序和程序代码编写的访问顺序不一致，会导致内存乱序访问。内存乱序访问的出现是为了提高程序执行的效率。内存乱序访问主要发生在如下两个阶段:
1. 编译时，编译器优化导致内存乱序访问
2. 执行时，多个CPU间交互引起的内存乱序访问。

编译器会把符合人类思维的代码（C语言代码）翻译成符合CPU运算规则的汇编指令，编译器了解底层CPU的思维逻辑，因此他会在翻译汇编指令时对其进行优化。如内存访问指令的重新排序可以提高指令级并行效率。然后，这些优化会与程序员原始代码逻辑不符，导致一些错误发生。编译时的乱序访问可以通过barrier()函数来规避:
```c
    #define barrier() __asm__ __volatile__("": : :"memory") 
```

barrier() 函数告诉编译器，不要为了性能优化而将这些代码重排。

由于现代处理器普遍采用超标量架构、乱序发射以及乱序执行等技术来提高指令级并行效率，因此指令的执行序列在处理器流水线中可能被打乱，与程序代码编写时序列不一致。


## 内存访问一致性
现代处理器采用多级存储结构，如何保证处理器对存储子系统访问的正确性也是一大挑战

原文： “以上这些内存一致性模型是针对存储器的读写指令展开的，还有一类目前广泛使用的模型，这类模型使用内存同步指令（也称为内存屏障指令）。” 
- 说明现代内存访问一致性模型是基于 内存同步指令（内存屏障指令） 来实现的

在ARM处理器中使用内存屏障指令的方式来实现同步访问。内存屏障指令的基本原则如下。
1. 所有在内存屏障指令之前的数据访问必须在内存屏障指令之前完成。
2. 所有在内存屏障指令后面的数据访问必须等待内存屏障指令执行完。
3. 多条内存屏障指令是按顺序执行的。


## 参考
1. 1.请阅读:  [奔跑吧Linux内核（第2版）卷1：基础架构#1.1.4　内存屏障产生的原因](../006.BOOKs/Run%20Linux%20Kernel%20(2nd%20Edition)%20Volume%201:%20Infrastructure.epub)#1.1.4　内存屏障产生的原因


