# 程序调用sleep()时CPU在摸鱼？底层休眠机制全解剖！
> 请先学习: [程序调用sleep()时CPU在摸鱼？底层休眠机制全解剖！](../../010.LESSONS/29899227803-1-192.mp4)

## 概要
+ `系统物理计时器`<sup>硬件设备，集成在CPU内部</sup>个数有限，因此，内核是通过软件让多个进程共用一个计时器：解决延迟的关键，就是单个计时器管理多个睡眠进程的方法<sub>基于CPU的调度算法</sub>。
+ Kernel `sleeping queue`: 哪些进程会被添加到sleeping queue中? 任何调用sleep的进程，都会被添加到sleeping queue中
+ `唤醒`: 计时器触发中断，调用操作系统，OS查看sleeping queue，将等待时间结束的进程移回就绪队列，使其再次执行。但可能还存在其他进程在等待，OS可以算出每个进程还剩多久，计时器将会被设置为最近一个需要唤醒的进程的剩余等待时间<sup>若有多个进程，则设置最近需要唤醒的那个进程的剩余等待时间</sup>，当计时器一到<sub>计时器为0</sub>，另一个中断就会触发，OS唤醒下一个进程并安排执行。
+ `重置定时器`<sup>重置为最近一个进程的剩余唤醒时间</sup> ：例如A进程在00:00:00调用sleep(15) , B进程在00:10:00调用sleep(3) , 那么B进程会先于A进程被唤醒，但是此时计时器是为进程A服务的<sub>`即剩余唤醒时间是A的： 剩余唤醒时间为0时，才会触发中断，将进程移回到就绪队列`</sub>，所以即使到了B进程应当唤醒的时间点，他也不会被唤醒<sub>因为计时器只会在A应当被唤醒的时刻才会发生中断</sub> ， 那么怎么处理? 将sleeping queue按照唤醒时间排序<sub>会使用高效的数据结构</sub>，计时器触发时，至少保证第一个进程需要被唤醒，同时会将所有的需要被唤醒的进程移回到就绪队列，直到还有一个有剩余唤醒时间的进程，此时，就需要将计时器的时间重置为最近一个需要被唤醒进程的剩余等待时间。

---

### sleep 会受如下因素影响
![wechat_2025-05-20_080552_898.png](./998.IMGS/wechat_2025-05-20_080552_898.png)