# rbp 寄存器<sup>X64</sup>
> rbp（栈帧基址指针）

+ rbp 通常用于指向当前函数的栈帧的基址，也就是局部变量和函数参数的起始位置。它指向了当前函数的局部数据存储区。
+ 在函数开始时，通常会通过 push %rbp 将 rbp 的值保存到栈上，然后通过 mov %rsp, %rbp 将 rsp 的值赋给 rbp，从而建立了一个新的栈帧。
+ 在函数结束时，通常会通过 leave 或 leaveq 指令来清理栈帧并还原 rbp 的值，以恢复到调用函数的栈帧。这使得函数能够正确返回并保持栈的一致性。

总之，rbp 和 rsp 寄存器在 x86-64 架构中用于管理函数调用栈，分别指向当前函数的栈帧基址和栈顶。这两个寄存器在函数调用和返回过程中起着关键的作用，确保了局部变量和控制流的正确管理。

## ebp
### ebp/rbp栈帧指针寄存器
`x86的栈帧指针寄存器是ebp`，`x64对应的是rbp`。该寄存器存放着当前函数栈帧的起始地址。由于栈是向下生长的，因此它的值一般总是大于esp/rsp的值，而从ebp/rbp至esp/rsp这一范围内的内存被称为当前函数的栈帧。而且往往上一层函数的栈顶地址(即esp/rsp的值)与当前函数栈帧指针(ebp/rbp)的值是相等的，因为在调用函数时总能看到开场白指令mov ebp, esp，即把当前esp值存放至ebp。


在汇编中，若想访问当前函数内的局部变量，既可以使用ebp/rbp来表示，也可以使用esp/rsp来表示。例如，假设函数有两个int型的变量，第一个变量可以使用[ebp-4]来访问，也可以使用[esp+4]来访问。这样来看ebp和esp似乎其中一个是累赘。不过对于早期的x86的CPU，可能不支持处理大范围的栈帧，因此设计了两个寄存器。而如今，在x64下rbp已经很少使用了。